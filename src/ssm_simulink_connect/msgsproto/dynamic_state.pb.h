// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dynamic_state.proto

#ifndef PROTOBUF_INCLUDED_dynamic_5fstate_2eproto
#define PROTOBUF_INCLUDED_dynamic_5fstate_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "vector3d.pb.h"
#include "pose.pb.h"
#include "time.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dynamic_5fstate_2eproto 

namespace protobuf_dynamic_5fstate_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dynamic_5fstate_2eproto
namespace ssm_msgs {
namespace msgs {
class DynamicState;
class DynamicStateDefaultTypeInternal;
extern DynamicStateDefaultTypeInternal _DynamicState_default_instance_;
}  // namespace msgs
}  // namespace ssm_msgs
namespace google {
namespace protobuf {
template<> ::ssm_msgs::msgs::DynamicState* Arena::CreateMaybeMessage<::ssm_msgs::msgs::DynamicState>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ssm_msgs {
namespace msgs {

// ===================================================================

class DynamicState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssm_msgs.msgs.DynamicState) */ {
 public:
  DynamicState();
  virtual ~DynamicState();

  DynamicState(const DynamicState& from);

  inline DynamicState& operator=(const DynamicState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicState(DynamicState&& from) noexcept
    : DynamicState() {
    *this = ::std::move(from);
  }

  inline DynamicState& operator=(DynamicState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicState* internal_default_instance() {
    return reinterpret_cast<const DynamicState*>(
               &_DynamicState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DynamicState* other);
  friend void swap(DynamicState& a, DynamicState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicState* New() const final {
    return CreateMaybeMessage<DynamicState>(NULL);
  }

  DynamicState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DynamicState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DynamicState& from);
  void MergeFrom(const DynamicState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gazebo.msgs.Vector3d LinearVelocity = 1;
  bool has_linearvelocity() const;
  void clear_linearvelocity();
  static const int kLinearVelocityFieldNumber = 1;
  private:
  const ::gazebo::msgs::Vector3d& _internal_linearvelocity() const;
  public:
  const ::gazebo::msgs::Vector3d& linearvelocity() const;
  ::gazebo::msgs::Vector3d* release_linearvelocity();
  ::gazebo::msgs::Vector3d* mutable_linearvelocity();
  void set_allocated_linearvelocity(::gazebo::msgs::Vector3d* linearvelocity);

  // required .gazebo.msgs.Vector3d AngluarVelocity = 2;
  bool has_angluarvelocity() const;
  void clear_angluarvelocity();
  static const int kAngluarVelocityFieldNumber = 2;
  private:
  const ::gazebo::msgs::Vector3d& _internal_angluarvelocity() const;
  public:
  const ::gazebo::msgs::Vector3d& angluarvelocity() const;
  ::gazebo::msgs::Vector3d* release_angluarvelocity();
  ::gazebo::msgs::Vector3d* mutable_angluarvelocity();
  void set_allocated_angluarvelocity(::gazebo::msgs::Vector3d* angluarvelocity);

  // required .gazebo.msgs.Vector3d LinearAcceleration = 3;
  bool has_linearacceleration() const;
  void clear_linearacceleration();
  static const int kLinearAccelerationFieldNumber = 3;
  private:
  const ::gazebo::msgs::Vector3d& _internal_linearacceleration() const;
  public:
  const ::gazebo::msgs::Vector3d& linearacceleration() const;
  ::gazebo::msgs::Vector3d* release_linearacceleration();
  ::gazebo::msgs::Vector3d* mutable_linearacceleration();
  void set_allocated_linearacceleration(::gazebo::msgs::Vector3d* linearacceleration);

  // required .gazebo.msgs.Vector3d AngluarAcceleration = 4;
  bool has_angluaracceleration() const;
  void clear_angluaracceleration();
  static const int kAngluarAccelerationFieldNumber = 4;
  private:
  const ::gazebo::msgs::Vector3d& _internal_angluaracceleration() const;
  public:
  const ::gazebo::msgs::Vector3d& angluaracceleration() const;
  ::gazebo::msgs::Vector3d* release_angluaracceleration();
  ::gazebo::msgs::Vector3d* mutable_angluaracceleration();
  void set_allocated_angluaracceleration(::gazebo::msgs::Vector3d* angluaracceleration);

  // required .gazebo.msgs.Pose Pose = 5;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 5;
  private:
  const ::gazebo::msgs::Pose& _internal_pose() const;
  public:
  const ::gazebo::msgs::Pose& pose() const;
  ::gazebo::msgs::Pose* release_pose();
  ::gazebo::msgs::Pose* mutable_pose();
  void set_allocated_pose(::gazebo::msgs::Pose* pose);

  // required .gazebo.msgs.Time Time = 6;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 6;
  private:
  const ::gazebo::msgs::Time& _internal_time() const;
  public:
  const ::gazebo::msgs::Time& time() const;
  ::gazebo::msgs::Time* release_time();
  ::gazebo::msgs::Time* mutable_time();
  void set_allocated_time(::gazebo::msgs::Time* time);

  // @@protoc_insertion_point(class_scope:ssm_msgs.msgs.DynamicState)
 private:
  void set_has_linearvelocity();
  void clear_has_linearvelocity();
  void set_has_angluarvelocity();
  void clear_has_angluarvelocity();
  void set_has_linearacceleration();
  void clear_has_linearacceleration();
  void set_has_angluaracceleration();
  void clear_has_angluaracceleration();
  void set_has_pose();
  void clear_has_pose();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gazebo::msgs::Vector3d* linearvelocity_;
  ::gazebo::msgs::Vector3d* angluarvelocity_;
  ::gazebo::msgs::Vector3d* linearacceleration_;
  ::gazebo::msgs::Vector3d* angluaracceleration_;
  ::gazebo::msgs::Pose* pose_;
  ::gazebo::msgs::Time* time_;
  friend struct ::protobuf_dynamic_5fstate_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DynamicState

// required .gazebo.msgs.Vector3d LinearVelocity = 1;
inline bool DynamicState::has_linearvelocity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicState::set_has_linearvelocity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynamicState::clear_has_linearvelocity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::_internal_linearvelocity() const {
  return *linearvelocity_;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::linearvelocity() const {
  const ::gazebo::msgs::Vector3d* p = linearvelocity_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.LinearVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Vector3d*>(
      &::gazebo::msgs::_Vector3d_default_instance_);
}
inline ::gazebo::msgs::Vector3d* DynamicState::release_linearvelocity() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.LinearVelocity)
  clear_has_linearvelocity();
  ::gazebo::msgs::Vector3d* temp = linearvelocity_;
  linearvelocity_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Vector3d* DynamicState::mutable_linearvelocity() {
  set_has_linearvelocity();
  if (linearvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Vector3d>(GetArenaNoVirtual());
    linearvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.LinearVelocity)
  return linearvelocity_;
}
inline void DynamicState::set_allocated_linearvelocity(::gazebo::msgs::Vector3d* linearvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linearvelocity_);
  }
  if (linearvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linearvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linearvelocity, submessage_arena);
    }
    set_has_linearvelocity();
  } else {
    clear_has_linearvelocity();
  }
  linearvelocity_ = linearvelocity;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.LinearVelocity)
}

// required .gazebo.msgs.Vector3d AngluarVelocity = 2;
inline bool DynamicState::has_angluarvelocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicState::set_has_angluarvelocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DynamicState::clear_has_angluarvelocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::_internal_angluarvelocity() const {
  return *angluarvelocity_;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::angluarvelocity() const {
  const ::gazebo::msgs::Vector3d* p = angluarvelocity_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.AngluarVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Vector3d*>(
      &::gazebo::msgs::_Vector3d_default_instance_);
}
inline ::gazebo::msgs::Vector3d* DynamicState::release_angluarvelocity() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.AngluarVelocity)
  clear_has_angluarvelocity();
  ::gazebo::msgs::Vector3d* temp = angluarvelocity_;
  angluarvelocity_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Vector3d* DynamicState::mutable_angluarvelocity() {
  set_has_angluarvelocity();
  if (angluarvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Vector3d>(GetArenaNoVirtual());
    angluarvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.AngluarVelocity)
  return angluarvelocity_;
}
inline void DynamicState::set_allocated_angluarvelocity(::gazebo::msgs::Vector3d* angluarvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(angluarvelocity_);
  }
  if (angluarvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angluarvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angluarvelocity, submessage_arena);
    }
    set_has_angluarvelocity();
  } else {
    clear_has_angluarvelocity();
  }
  angluarvelocity_ = angluarvelocity;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.AngluarVelocity)
}

// required .gazebo.msgs.Vector3d LinearAcceleration = 3;
inline bool DynamicState::has_linearacceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DynamicState::set_has_linearacceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DynamicState::clear_has_linearacceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::_internal_linearacceleration() const {
  return *linearacceleration_;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::linearacceleration() const {
  const ::gazebo::msgs::Vector3d* p = linearacceleration_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.LinearAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Vector3d*>(
      &::gazebo::msgs::_Vector3d_default_instance_);
}
inline ::gazebo::msgs::Vector3d* DynamicState::release_linearacceleration() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.LinearAcceleration)
  clear_has_linearacceleration();
  ::gazebo::msgs::Vector3d* temp = linearacceleration_;
  linearacceleration_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Vector3d* DynamicState::mutable_linearacceleration() {
  set_has_linearacceleration();
  if (linearacceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Vector3d>(GetArenaNoVirtual());
    linearacceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.LinearAcceleration)
  return linearacceleration_;
}
inline void DynamicState::set_allocated_linearacceleration(::gazebo::msgs::Vector3d* linearacceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linearacceleration_);
  }
  if (linearacceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linearacceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linearacceleration, submessage_arena);
    }
    set_has_linearacceleration();
  } else {
    clear_has_linearacceleration();
  }
  linearacceleration_ = linearacceleration;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.LinearAcceleration)
}

// required .gazebo.msgs.Vector3d AngluarAcceleration = 4;
inline bool DynamicState::has_angluaracceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DynamicState::set_has_angluaracceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DynamicState::clear_has_angluaracceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::_internal_angluaracceleration() const {
  return *angluaracceleration_;
}
inline const ::gazebo::msgs::Vector3d& DynamicState::angluaracceleration() const {
  const ::gazebo::msgs::Vector3d* p = angluaracceleration_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.AngluarAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Vector3d*>(
      &::gazebo::msgs::_Vector3d_default_instance_);
}
inline ::gazebo::msgs::Vector3d* DynamicState::release_angluaracceleration() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.AngluarAcceleration)
  clear_has_angluaracceleration();
  ::gazebo::msgs::Vector3d* temp = angluaracceleration_;
  angluaracceleration_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Vector3d* DynamicState::mutable_angluaracceleration() {
  set_has_angluaracceleration();
  if (angluaracceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Vector3d>(GetArenaNoVirtual());
    angluaracceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.AngluarAcceleration)
  return angluaracceleration_;
}
inline void DynamicState::set_allocated_angluaracceleration(::gazebo::msgs::Vector3d* angluaracceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(angluaracceleration_);
  }
  if (angluaracceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angluaracceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angluaracceleration, submessage_arena);
    }
    set_has_angluaracceleration();
  } else {
    clear_has_angluaracceleration();
  }
  angluaracceleration_ = angluaracceleration;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.AngluarAcceleration)
}

// required .gazebo.msgs.Pose Pose = 5;
inline bool DynamicState::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DynamicState::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DynamicState::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::gazebo::msgs::Pose& DynamicState::_internal_pose() const {
  return *pose_;
}
inline const ::gazebo::msgs::Pose& DynamicState::pose() const {
  const ::gazebo::msgs::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.Pose)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Pose*>(
      &::gazebo::msgs::_Pose_default_instance_);
}
inline ::gazebo::msgs::Pose* DynamicState::release_pose() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.Pose)
  clear_has_pose();
  ::gazebo::msgs::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Pose* DynamicState::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.Pose)
  return pose_;
}
inline void DynamicState::set_allocated_pose(::gazebo::msgs::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.Pose)
}

// required .gazebo.msgs.Time Time = 6;
inline bool DynamicState::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DynamicState::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DynamicState::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::gazebo::msgs::Time& DynamicState::_internal_time() const {
  return *time_;
}
inline const ::gazebo::msgs::Time& DynamicState::time() const {
  const ::gazebo::msgs::Time* p = time_;
  // @@protoc_insertion_point(field_get:ssm_msgs.msgs.DynamicState.Time)
  return p != NULL ? *p : *reinterpret_cast<const ::gazebo::msgs::Time*>(
      &::gazebo::msgs::_Time_default_instance_);
}
inline ::gazebo::msgs::Time* DynamicState::release_time() {
  // @@protoc_insertion_point(field_release:ssm_msgs.msgs.DynamicState.Time)
  clear_has_time();
  ::gazebo::msgs::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::gazebo::msgs::Time* DynamicState::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::gazebo::msgs::Time>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssm_msgs.msgs.DynamicState.Time)
  return time_;
}
inline void DynamicState::set_allocated_time(::gazebo::msgs::Time* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    set_has_time();
  } else {
    clear_has_time();
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:ssm_msgs.msgs.DynamicState.Time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace ssm_msgs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dynamic_5fstate_2eproto
